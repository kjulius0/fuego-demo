/**
 * Generated by orval v7.11.2 üç∫
 * Do not edit manually.
 * OpenAPI
 * 
This is the autogenerated OpenAPI documentation for your [Fuego](https://github.com/go-fuego/fuego) API.

Below is a Fuego Cheatsheet to help you get started. Don't hesitate to check the [Fuego documentation](https://go-fuego.dev) for more details.

Happy coding! üî•

## Usage

### Route registration

```go
func main() {
	// Create a new server
	s := fuego.NewServer()

	// Register some routes
	fuego.Post(s, "/hello", myController)
	fuego.Get(s, "/myPath", otherController)
	fuego.Put(s, "/hello", thirdController)

	adminRoutes := fuego.Group(s, "/admin")
	fuego.Use(adminRoutes, myMiddleware) // This middleware (for authentication, etc...) will be available for routes starting by /admin/*, 
	fuego.Get(adminRoutes, "/hello", groupController) // This route will be available at /admin/hello

	// Start the server
	s.Start()
}
```

### Basic controller

```go
type MyBody struct {
	Name string `json:"name" validate:"required,max=30"`
}

type MyResponse struct {
	Answer string `json:"answer"`
}

func hello(ctx fuego.ContextWithBody[MyBody]) (*MyResponse, error) {
	body, err := ctx.Body()
	if err != nil {
		return nil, err
	}

	return &MyResponse{Answer: "Hello " + body.Name}, nil
}
```

### Add openAPI information to the route

```go
import (
	"github.com/go-fuego/fuego"
	"github.com/go-fuego/fuego/option"
	"github.com/go-fuego/fuego/param"
)

func main() {
	s := fuego.NewServer()

	// Custom OpenAPI options
	fuego.Post(s, "/", myController
		option.Description("This route does something..."),
		option.Summary("This is my summary"),
		option.Tags("MyTag"), // A tag is set by default according to the return type (can be deactivated)
		option.Deprecated(), // Marks the route as deprecated in the OpenAPI spec

		option.Query("name", "Declares a query parameter with default value", param.Default("Carmack")),
		option.Header("Authorization", "Bearer token", param.Required()),
		optionPagination,
		optionCustomBehavior,
	)

	s.Run()
}

var optionPagination = option.Group(
	option.QueryInt("page", "Page number", param.Default(1), param.Example("1st page", 1), param.Example("42nd page", 42)),
	option.QueryInt("perPage", "Number of items per page"),
)

var optionCustomBehavior = func(r *fuego.BaseRoute) {
	r.XXX = "YYY"
}
```

Then, in the controller

```go
type MyResponse struct {
	Answer string `json:"answer"`
}

func getAllPets(ctx fuego.ContextNoBody) (*MyResponse, error) {
	name := ctx.QueryParam("name")
	perPage, _ := ctx.QueryParamIntErr("per_page")

	return &MyResponse{Answer: "Hello " + name}, nil
}
```

 * OpenAPI spec version: 0.0.1
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios';

/**
 * AnimalRequest schema
 */
export interface AnimalRequest {
  /** Secret number to access animals */
  secret: number;
}

/**
 * Animal habitat
 */
export type AnimalResponseHabitat = typeof AnimalResponseHabitat[keyof typeof AnimalResponseHabitat];


// eslint-disable-next-line @typescript-eslint/no-redeclare
export const AnimalResponseHabitat = {
  Savanna: 'Savanna',
  Grassland: 'Grassland',
  Forest: 'Forest',
  Arctic: 'Arctic',
  Ocean: 'Ocean',
  Meadow: 'Meadow',
  Jungle: 'Jungle',
  Mountain: 'Mountain',
} as const;

/**
 * AnimalResponse schema
 */
export interface AnimalResponse {
  /** Animal habitat */
  habitat?: AnimalResponseHabitat;
  /** Random animal ID */
  id?: number;
  /** Animal name */
  name?: string;
  /** Whether secret was correct */
  secret?: boolean;
  /** Animal type */
  type?: string;
}

/**
 * GreetingInput schema
 */
export interface GreetingInput {
  /**
   * Name to greet
   * @minLength 1
   * @maxLength 50
   */
  name: string;
}

/**
 * GreetingResponse schema
 */
export interface GreetingResponse {
  /** Greeting message */
  message?: string;
  /** When the greeting was generated */
  timestamp?: string;
}

/**
 * Additional information about the error
 * @nullable
 */
export type HTTPErrorErrorsItemMore = {[key: string]: unknown | null} | null;

/**
 * @nullable
 */
export type HTTPErrorErrorsItem = {
  /**
   * Additional information about the error
   * @nullable
   */
  more?: HTTPErrorErrorsItemMore;
  /** For example, name of the parameter that caused the error */
  name?: string;
  /** Human readable error message */
  reason?: string;
} | null;

/**
 * HTTPError schema
 */
export interface HTTPError {
  /**
   * Human readable error message
   * @nullable
   */
  detail?: string | null;
  /** @nullable */
  errors?: HTTPErrorErrorsItem[] | null;
  /** @nullable */
  instance?: string | null;
  /**
   * HTTP status code
   * @nullable
   */
  status?: number | null;
  /**
   * Short title of the error
   * @nullable
   */
  title?: string | null;
  /**
   * URL of the error type. Can be used to lookup the error in a documentation
   * @nullable
   */
  type?: string | null;
}

/**
 * HealthResponse schema
 */
export interface HealthResponse {
  /** Health status */
  status: string;
  /** Current server time */
  time: string;
}

/**
 * UserResponse schema
 */
export interface UserResponse {
  /** User email */
  email?: string;
  /** User ID */
  id?: number;
  /** When the user joined */
  join_date?: string;
  /** User name */
  name?: string;
}

/**
 * unknown-interface schema
 */
export interface UnknownInterface {}

/**
 * #### Controller: 

`main.animalHandler`

#### Middlewares:

- `github.com/go-fuego/fuego.defaultLogger.middleware`
- `main.authMiddleware`

---

Returns a random animal if the correct secret number (22) is provided
 * @summary Get random animal
 */
export const pOSTApiAnimal = (
    animalRequest: AnimalRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AnimalResponse>> => {
    
    
    return axios.default.post(
      `/api/animal`,
      animalRequest,options
    );
  }



export const getPOSTApiAnimalMutationOptions = <TError = AxiosError<HTTPError | HTTPError | null>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pOSTApiAnimal>>, TError,{data: AnimalRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof pOSTApiAnimal>>, TError,{data: AnimalRequest}, TContext> => {

const mutationKey = ['pOSTApiAnimal'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pOSTApiAnimal>>, {data: AnimalRequest}> = (props) => {
          const {data} = props ?? {};

          return  pOSTApiAnimal(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type POSTApiAnimalMutationResult = NonNullable<Awaited<ReturnType<typeof pOSTApiAnimal>>>
    export type POSTApiAnimalMutationBody = AnimalRequest
    export type POSTApiAnimalMutationError = AxiosError<HTTPError | HTTPError | null>

    /**
 * @summary Get random animal
 */
export const usePOSTApiAnimal = <TError = AxiosError<HTTPError | HTTPError | null>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pOSTApiAnimal>>, TError,{data: AnimalRequest}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof pOSTApiAnimal>>,
        TError,
        {data: AnimalRequest},
        TContext
      > => {

      const mutationOptions = getPOSTApiAnimalMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * #### Controller: 

`main.greetingHandler`

#### Middlewares:

- `github.com/go-fuego/fuego.defaultLogger.middleware`
- `main.authMiddleware`

---

Takes a name and returns a personalized greeting message
 * @summary Generate a greeting
 */
export const pOSTApiGreeting = (
    greetingInput: GreetingInput, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<GreetingResponse>> => {
    
    
    return axios.default.post(
      `/api/greeting`,
      greetingInput,options
    );
  }



export const getPOSTApiGreetingMutationOptions = <TError = AxiosError<HTTPError | HTTPError | null>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pOSTApiGreeting>>, TError,{data: GreetingInput}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof pOSTApiGreeting>>, TError,{data: GreetingInput}, TContext> => {

const mutationKey = ['pOSTApiGreeting'];
const {mutation: mutationOptions, axios: axiosOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, axios: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof pOSTApiGreeting>>, {data: GreetingInput}> = (props) => {
          const {data} = props ?? {};

          return  pOSTApiGreeting(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type POSTApiGreetingMutationResult = NonNullable<Awaited<ReturnType<typeof pOSTApiGreeting>>>
    export type POSTApiGreetingMutationBody = GreetingInput
    export type POSTApiGreetingMutationError = AxiosError<HTTPError | HTTPError | null>

    /**
 * @summary Generate a greeting
 */
export const usePOSTApiGreeting = <TError = AxiosError<HTTPError | HTTPError | null>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof pOSTApiGreeting>>, TError,{data: GreetingInput}, TContext>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof pOSTApiGreeting>>,
        TError,
        {data: GreetingInput},
        TContext
      > => {

      const mutationOptions = getPOSTApiGreetingMutationOptions(options);

      return useMutation(mutationOptions , queryClient);
    }
    
/**
 * #### Controller: 

`main.userHandler`

#### Middlewares:

- `github.com/go-fuego/fuego.defaultLogger.middleware`
- `main.authMiddleware`

---

Retrieve user information by user ID
 * @summary Get user information
 */
export const gETApiUserId = (
    id: string, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<UserResponse>> => {
    
    
    return axios.default.get(
      `/api/user/${id}`,options
    );
  }


export const getGETApiUserIdQueryKey = (id?: string,) => {
    return [`/api/user/${id}`] as const;
    }

    
export const getGETApiUserIdQueryOptions = <TData = Awaited<ReturnType<typeof gETApiUserId>>, TError = AxiosError<HTTPError | HTTPError | null>>(id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof gETApiUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGETApiUserIdQueryKey(id);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof gETApiUserId>>> = ({ signal }) => gETApiUserId(id, { signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(id), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof gETApiUserId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GETApiUserIdQueryResult = NonNullable<Awaited<ReturnType<typeof gETApiUserId>>>
export type GETApiUserIdQueryError = AxiosError<HTTPError | HTTPError | null>


export function useGETApiUserId<TData = Awaited<ReturnType<typeof gETApiUserId>>, TError = AxiosError<HTTPError | HTTPError | null>>(
 id: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof gETApiUserId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof gETApiUserId>>,
          TError,
          Awaited<ReturnType<typeof gETApiUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGETApiUserId<TData = Awaited<ReturnType<typeof gETApiUserId>>, TError = AxiosError<HTTPError | HTTPError | null>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof gETApiUserId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof gETApiUserId>>,
          TError,
          Awaited<ReturnType<typeof gETApiUserId>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGETApiUserId<TData = Awaited<ReturnType<typeof gETApiUserId>>, TError = AxiosError<HTTPError | HTTPError | null>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof gETApiUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get user information
 */

export function useGETApiUserId<TData = Awaited<ReturnType<typeof gETApiUserId>>, TError = AxiosError<HTTPError | HTTPError | null>>(
 id: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof gETApiUserId>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGETApiUserIdQueryOptions(id,options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}




/**
 * #### Controller: 

`main.healthHandler`

#### Middlewares:

- `github.com/go-fuego/fuego.defaultLogger.middleware`

---

Returns the health status of the API server
 * @summary Health check endpoint
 */
export const gETHealth = (
     options?: AxiosRequestConfig
 ): Promise<AxiosResponse<HealthResponse>> => {
    
    
    return axios.default.get(
      `/health`,options
    );
  }


export const getGETHealthQueryKey = () => {
    return [`/health`] as const;
    }

    
export const getGETHealthQueryOptions = <TData = Awaited<ReturnType<typeof gETHealth>>, TError = AxiosError<HTTPError | HTTPError | null>>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof gETHealth>>, TError, TData>>, axios?: AxiosRequestConfig}
) => {

const {query: queryOptions, axios: axiosOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getGETHealthQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof gETHealth>>> = ({ signal }) => gETHealth({ signal, ...axiosOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof gETHealth>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type GETHealthQueryResult = NonNullable<Awaited<ReturnType<typeof gETHealth>>>
export type GETHealthQueryError = AxiosError<HTTPError | HTTPError | null>


export function useGETHealth<TData = Awaited<ReturnType<typeof gETHealth>>, TError = AxiosError<HTTPError | HTTPError | null>>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof gETHealth>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof gETHealth>>,
          TError,
          Awaited<ReturnType<typeof gETHealth>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGETHealth<TData = Awaited<ReturnType<typeof gETHealth>>, TError = AxiosError<HTTPError | HTTPError | null>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof gETHealth>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof gETHealth>>,
          TError,
          Awaited<ReturnType<typeof gETHealth>>
        > , 'initialData'
      >, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useGETHealth<TData = Awaited<ReturnType<typeof gETHealth>>, TError = AxiosError<HTTPError | HTTPError | null>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof gETHealth>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Health check endpoint
 */

export function useGETHealth<TData = Awaited<ReturnType<typeof gETHealth>>, TError = AxiosError<HTTPError | HTTPError | null>>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof gETHealth>>, TError, TData>>, axios?: AxiosRequestConfig}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getGETHealthQueryOptions(options)

  const query = useQuery(queryOptions , queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = queryOptions.queryKey ;

  return query;
}
