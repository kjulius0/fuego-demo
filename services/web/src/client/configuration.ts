/* tslint:disable */
/* eslint-disable */
/**
 * OpenAPI
 *  This is the autogenerated OpenAPI documentation for your [Fuego](https://github.com/go-fuego/fuego) API.  Below is a Fuego Cheatsheet to help you get started. Don\'t hesitate to check the [Fuego documentation](https://go-fuego.dev) for more details.  Happy coding! ðŸ”¥  ## Usage  ### Route registration  ```go func main() {  // Create a new server  s := fuego.NewServer()   // Register some routes  fuego.Post(s, \"/hello\", myController)  fuego.Get(s, \"/myPath\", otherController)  fuego.Put(s, \"/hello\", thirdController)   adminRoutes := fuego.Group(s, \"/admin\")  fuego.Use(adminRoutes, myMiddleware) // This middleware (for authentication, etc...) will be available for routes starting by /admin/_*,   fuego.Get(adminRoutes, \"/hello\", groupController) // This route will be available at /admin/hello   // Start the server  s.Start() } ```  ### Basic controller  ```go type MyBody struct {  Name string `json:\"name\" validate:\"required,max=30\"` }  type MyResponse struct {  Answer string `json:\"answer\"` }  func hello(ctx fuego.ContextWithBody[MyBody]) (*MyResponse, error) {  body, err := ctx.Body()  if err != nil {   return nil, err  }   return &MyResponse{Answer: \"Hello \" + body.Name}, nil } ```  ### Add openAPI information to the route  ```go import (  \"github.com/go-fuego/fuego\"  \"github.com/go-fuego/fuego/option\"  \"github.com/go-fuego/fuego/param\" )  func main() {  s := fuego.NewServer()   // Custom OpenAPI options  fuego.Post(s, \"/\", myController   option.Description(\"This route does something...\"),   option.Summary(\"This is my summary\"),   option.Tags(\"MyTag\"), // A tag is set by default according to the return type (can be deactivated)   option.Deprecated(), // Marks the route as deprecated in the OpenAPI spec    option.Query(\"name\", \"Declares a query parameter with default value\", param.Default(\"Carmack\")),   option.Header(\"Authorization\", \"Bearer token\", param.Required()),   optionPagination,   optionCustomBehavior,  )   s.Run() }  var optionPagination = option.Group(  option.QueryInt(\"page\", \"Page number\", param.Default(1), param.Example(\"1st page\", 1), param.Example(\"42nd page\", 42)),  option.QueryInt(\"perPage\", \"Number of items per page\"), )  var optionCustomBehavior = func(r *fuego.BaseRoute) {  r.XXX = \"YYY\" } ```  Then, in the controller  ```go type MyResponse struct {  Answer string `json:\"answer\"` }  func getAllPets(ctx fuego.ContextNoBody) (*MyResponse, error) {  name := ctx.QueryParam(\"name\")  perPage, _ := ctx.QueryParamIntErr(\"per_page\")   return &MyResponse{Answer: \"Hello \" + name}, nil } ``` 
 *
 * The version of the OpenAPI document: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


export interface ConfigurationParameters {
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    username?: string;
    password?: string;
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    basePath?: string;
    serverIndex?: number;
    baseOptions?: any;
    formDataCtor?: new () => any;
}

export class Configuration {
    /**
     * parameter for apiKey security
     * @param name security name
     * @memberof Configuration
     */
    apiKey?: string | Promise<string> | ((name: string) => string) | ((name: string) => Promise<string>);
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    username?: string;
    /**
     * parameter for basic security
     *
     * @type {string}
     * @memberof Configuration
     */
    password?: string;
    /**
     * parameter for oauth2 security
     * @param name security name
     * @param scopes oauth2 scope
     * @memberof Configuration
     */
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string) | ((name?: string, scopes?: string[]) => Promise<string>);
    /**
     * override base path
     *
     * @type {string}
     * @memberof Configuration
     */
    basePath?: string;
    /**
     * override server index
     *
     * @type {number}
     * @memberof Configuration
     */
    serverIndex?: number;
    /**
     * base options for axios calls
     *
     * @type {any}
     * @memberof Configuration
     */
    baseOptions?: any;
    /**
     * The FormData constructor that will be used to create multipart form data
     * requests. You can inject this here so that execution environments that
     * do not support the FormData class can still run the generated client.
     *
     * @type {new () => FormData}
     */
    formDataCtor?: new () => any;

    constructor(param: ConfigurationParameters = {}) {
        this.apiKey = param.apiKey;
        this.username = param.username;
        this.password = param.password;
        this.accessToken = param.accessToken;
        this.basePath = param.basePath;
        this.serverIndex = param.serverIndex;
        this.baseOptions = {
            ...param.baseOptions,
            headers: {
                ...param.baseOptions?.headers,
            },
        };
        this.formDataCtor = param.formDataCtor;
    }

    /**
     * Check if the given MIME is a JSON MIME.
     * JSON MIME examples:
     *   application/json
     *   application/json; charset=UTF8
     *   APPLICATION/JSON
     *   application/vnd.company+json
     * @param mime - MIME (Multipurpose Internet Mail Extensions)
     * @return True if the given MIME is JSON, false otherwise.
     */
    public isJsonMime(mime: string): boolean {
        const jsonMime: RegExp = new RegExp('^(application\/json|[^;/ \t]+\/[^;/ \t]+[+]json)[ \t]*(;.*)?$', 'i');
        return mime !== null && (jsonMime.test(mime) || mime.toLowerCase() === 'application/json-patch+json');
    }
}
